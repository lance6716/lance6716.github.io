---
layout: post
title:  "Specifying Systems 第三章笔记"
tags: tech
---

本章描述一个异步的数据传输设备，它有三个引脚`val`，`rdy`，`ack`。`val`引脚传输数据，`rdy`和`ack`引脚表示设备的状态。当`rdy`和`ack`相等时可以发送数据，并在发送后调整`rdy`为`rdy`和`ack`不相等，等待接收方接受数据并将`ack`设置为相等。

规范是对系统的抽象，它能确保在这种程度的抽象上，系统具有某些性质，但是它不能确保抽象没有描述的事情会不会影响系统。优秀的工程师应当将系统的关键进行抽象，舍弃不重要的细节。抽象在 TLA+ 规范中具体而言，是指选择系统的那些变量进行描述，以及选择什么粒度的*步*描述系统的变化。对这个设备而言，本章的抽象将发送数据和调整`rdy`抽象为原子操作。

# 3.1 第一个规范

系统抽象为上述三个变量，`val`的取值与抽象无关，不妨假设为一个集合`Data`。这可以通过`CONSTANT`关键字表达
```
CONSTANT  Data
```
我们想确保变量总是满足一定的取值范围（*类型*），这可以通过一个公式表达。注意 TLA+ 对缩进敏感。
```
TypeInvariant == /\ val \in Data
                 /\ rdy \in {0, 1}
                 /\ ack \in {0, 1}
```
这又被叫做*类型不变量*。

更正式的说，*不变量*满足规范的如下*定理*
```
THEOREM specification => []invariant
```
一个限定变量取值集合的*不变量*叫做*类型不变量*，该集合又叫做变量的*类型*。

系统的初始状态和状态转移描述较为简单。其中使用了`UNCHANGED`关键字和`<<element_1, element_2, ...>>`表示元组。

# 3.2 另一个规范

可以把`val`，`rdy`，`ack`的取值封装为一个记录，`val`，`rdy`，`ack`是记录的域。通过`record.field`访问一个域。通过`[field1 |-> value1, ...]`表示`record.field1 = value1 /\ ...`。通过`[field1 : type1, ...]`限定域的类型表示记录的类型，即
```
TypeInvariant  ==  chan \in [val : Data,  rdy : {0, 1},  ack : {0, 1}]
```
通过`action(parameter)`表示带参数的*行为*，我们可以使用如下的*行为*描述发送数据时的状态转移：
```
Send(d) ==  /\ chan.rdy = chan.ack
            /\ chan' = [chan EXCEPT !.val = d, !.rdy = 1 - @]
```
其中`EXCEPT`与`!`组合表明新记录在某些域上有新取值，`@`表示这个域的旧值。可以验证使该*行为*为真的状态转移确实描述了可发送的状态以及发送后系统的改变。

# 3.3 类型：一个提示

在此强调，TLA+ 在编程语言的层面上是无类型的，*类型不变量*只是一个 TLA+ 能推导的公式。

# 3.4 定义

标识符（可能带有参数）与`==`右边的表达式的关系与一般编程语言一致。标识符不能重复定义。

`VARIABLE`和`CONSTANT`作用域是模块，`EXTEND module`可以导入其他模块的标识符和运算符到本模块。量词和带参数标识符定义变量的作用域是该表达式。

# 3.5 注释

以下是两种形式的注释
```
(* comment *)
\* comment
```
注释可以嵌套。

